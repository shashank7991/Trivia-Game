# Building a Software System with Clojure

Let's us look a simple approach to building a simple trivia game with clojure.  Our approach here is as followed:

* We're going to separate the client code from the server code
* The client code will largely be based on the `event-pattern` example
* The server code is `plug-n-play` in a sense that you can swap in either `luminus` or `pedestal`

## Setup the project

Let's create two separate projects under the folder `trivia-game`

```bash
lein new pedestal-service trivia
lein new trivia-cljs
```

### Modify the server `trivia`

First we want to be able to support `selmer` so let us update `project.clj`

```clojure
(defproject trivia "0.0.1-development"
  :dependencies [[org.clojure/clojure "1.7.0"]
                 [selmer "0.9.5"]
                 [markdown-clj "0.9.80"]
                 [environ "1.0.1"]
                 [metosin/ring-middleware-format "0.6.0"]
                 [metosin/ring-http-response "0.6.5"]
                 [ring/ring-defaults "0.1.5"]
                 [io.pedestal/pedestal.service "0.4.1"]
                 [io.pedestal/pedestal.jetty "0.4.1"]
                 [ch.qos.logback/logback-classic "1.1.3" :exclusions [org.slf4j/slf4j-api]]
                 [org.slf4j/jul-to-slf4j "1.7.12"]
                 [org.slf4j/jcl-over-slf4j "1.7.12"]
                 [org.slf4j/log4j-over-slf4j "1.7.12"]]
  :min-lein-version "2.0.0"
  :resource-paths ["config", "resources"]
  :profiles {:dev {:aliases {"run-dev" ["trampoline" "run" "-m" "trivia.server/run-dev"]}
                   :dependencies [[io.pedestal/pedestal.service-tools "0.4.1"]]}
             :uberjar {:aot [trivia.server]}}
  :main ^{:skip-aot true} trivia.server)
```

Next, let's create a file `src/trivia/layout.clj`

```clojure
(ns trivia.layout
  (:require [selmer.parser :as parser]
            [selmer.filters :as filters]
            [markdown.core :refer [md-to-html-string]]
            [ring.util.http-response :refer [content-type ok]]
            [ring.util.anti-forgery :refer [anti-forgery-field]]
            [ring.middleware.anti-forgery :refer [*anti-forgery-token*]]
            [environ.core :refer [env]]))

(declare ^:dynamic *app-context*)
(parser/set-resource-path!  (clojure.java.io/resource "templates"))
(parser/add-tag! :csrf-field (fn [_ _] (anti-forgery-field)))
(filters/add-filter! :markdown (fn [content] [:safe (md-to-html-string content)]))

(defn render
  "renders the HTML template located relative to resources/templates"
  [template & [params]]
  (content-type
   (ok
    (parser/render-file
     template
     (assoc params
            :page template
            :dev (env :dev)
            :csrf-token *anti-forgery-token*
            :servlet-context *app-context*)))
   "text/html; charset=utf-8"))

(defn error-page
  "error-details should be a map containing the following keys:
   :status - error status
   :title - error title (optional)
   :message - detailed error message (optional)
   returns a response map with the error page as the body
   and the status specified by the status key"
  [error-details]
  {:status  (:status error-details)
   :headers {"Content-Type" "text/html; charset=utf-8"}
   :body    (parser/render-file "error.html" error-details)})
```

We want to create a simple `/selmer` endpoint to validate our service is working.  Modify `service.clj`

```clojure
(ns trivia.service
  (:require [trivia.layout :as layout]
            [io.pedestal.http :as bootstrap]
            [io.pedestal.http.route :as route]
            [io.pedestal.http.body-params :as body-params]
            [io.pedestal.http.route.definition :refer [defroutes]]
            [ring.util.response :as ring-resp]))

(defn about-page
  [request]
  (ring-resp/response (format "Clojure %s - served from %s"
                              (clojure-version)
                              (route/url-for ::about-page))))

(defn home-page
  [request]
  (ring-resp/response "Hello World!"))

(defn selmer-page
  [request]
  (layout/render "example.html" {:title "example"}))

(defroutes routes
  [[["/" {:get home-page}
     ^:interceptors [(body-params/body-params) bootstrap/html-body]
     ["/selmer" {:get selmer-page}]
     ["/about" {:get about-page}]]]])

(def service {:env :prod
              ::bootstrap/routes routes
              ::bootstrap/resource-path "/public"
              ::bootstrap/type :jetty
              ::bootstrap/port 8080})
```

Finally let's create `resources/templates/example.html` as followed

```html
<html>
  <head>
    <title>{{title}}</title>
  </head>
  <body>
    <h1>{{title}}</h1>
    <p>testing from selmer</p>
  </body>
</html>
```

We can now point our browser to `http://localhost:8080/selmer` and we should see a template page generated by `selmer`.  Note that `{:title "example"}` is map that is passed into `example.html`.

### Modify the client `trivia-cljs`

Update `project.clj` with some small changes

```clojure
(defproject trivia-cljs "0.0.1-development"
  :plugins [[lein-cljsbuild "1.0.0"]]
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [org.clojure/clojurescript "0.0-2173"]
                 [domina "1.0.3"]
                 [com.cognitect/transit-cljs "0.8.152"]
                 [compojure "1.4.0"]
                 [ring/ring-jetty-adapter "1.4.0"]]
  :cljsbuild
  {:builds
   [{:compiler
     {:output-to "../trivia/resources/public/js/client.js",
      :optimizations :whitespace,
      :pretty-print true},
     :source-paths ["src-cljs"]}]})
```

Note the changes:

* `:output-to` is set to `"../trivia/resources/public/js/client.js"`. This means that the directory `resources/public/js` must exist in the `trivia` project folder.  The idea here is that when we compile the clojurescript with the command `lein cljsbuild once` or `lein cljsbuild auto` the entire clojurescript package is generated into a file `client.js`

* `:source-paths` includes `"src-cljs"` which means that this is where we will put the `.cljs` files.

## Putting everything together

At this point we've demonstrated that we can update the server code `trivia` to support `selmer` and (separately) update `trivia-cljs` to compile and generate `client.js` that can be used with any views requiring event-driven actions.  Let's put together the (almost) complete trivia game.

### Generate an SPA view `game.html`

Create `trivia/resources/templates/game.html`

```html
<html>
  <head>
    <title>{{title}}</title>
  </head>
  <body>
    <h1>{{title}}</h1>
    <form id="eval-form">
      <p><input id="btn-get-question" type="button" value="get-question"/>
          <input id="btn-check-answer" type="button" value="check" /></p>
    </form>
    <hr/>
    <h2>Question</h2>
    <div id="question-div">question...</div>

    <h2>Result</h2>
    <div id="result-div">result...</div>

    <script src="/js/client.js" language="javascript"></script>
    <script type="text/javascript" language="javascript">
      trivia.client.main()
    </script>
  </body>
</html>
```

### Update the event code `client.cljs`

Update the `trivia-cljs/src-cljs/client.cljs` so that it can request JSON and generate HTML accordingly:

```clojure
(ns trivia.client
  (:require [goog.net.XhrIo :as xhr]
            [cljs.reader :as reader]
            [domina :as d]
            [domina.events :as events]))

(def btn-get-question-id "btn-get-question")
(def btn-check-answer-id "btn-check-answer")
(def div-question-id "question-div")
(def div-result-id "result-div")

(defn serialize [m] (str m))
(defn de-serialize [s] (reader/read-string s))

(defn choice-to-html [choice]
  (str "<li>" choice "</li>"))

(defn choices-to-html [choices]
  (apply str (map choice-to-html choices)))

(defn question-to-html [buffer]
  (let [m (de-serialize buffer)
        q (:q m)]
    (str "<form>"
         q "<br/>"
         "<ol>"
         (choices-to-html (:c m))
         "</ol>"
         "<input id=answer-box type=text />"
         "</form>")))

(defn receive-question-callback [event]
  (d/set-inner-html! (d/by-id div-question-id)
                     (question-to-html (.getResponseText (.-target event)))))

(defn receive-result-callback [event]
  (d/set-text! (d/by-id div-result-id)
               (.getResponseText (.-target event))))

(defn get-question [event]
  (xhr/send "/get-question" receive-question-callback "GET" "")
  (events/stop-propagation event)
  (events/prevent-default event))

(defn check-answer [event]
  (let [a (.-value (d/by-id "answer-box"))
        b {:answer a}
        body (serialize b)]
    (xhr/send "/check-answer" receive-result-callback "POST" body)
    (events/stop-propagation event)
    (events/prevent-default event)))

(defn ^:export main []
  (events/listen! (d/by-id btn-check-answer-id)
                  :click check-answer)
  (events/listen! (d/by-id btn-get-question-id)
                  :click get-question))
```

The key concept here is that serialized clojure maps are sent from the server to the client and are converted to `html` and generated accordingly.  The secret source (if you can call it that) is in the functions `receive-question-callback` and `question-to-html`. 

### Update the microservices `service.clj`

Finally, we need to update `trivia/src/trivia/service.clj` so that the end points can respond to client correctly.

```clojure
(ns trivia.service
  (:require [trivia.layout :as layout]
            [io.pedestal.http :as bootstrap]
            [io.pedestal.http.route :as route]
            [io.pedestal.http.body-params :as body-params]
            [io.pedestal.http.route.definition :refer [defroutes]]
            [ring.util.response :as ring-resp]))

(defn about-page
  [request]
  (ring-resp/response (format "Clojure %s - served from %s"
                              (clojure-version)
                              (route/url-for ::about-page))))

(defn home-page
  [request]
  (ring-resp/response "Hello World!"))

(defn selmer-page
  [request]
  (layout/render "example.html" {:title "example"}))

(defn game-page
  [request]
  (layout/render "game.html" {:title "Trivia Game"}))

(def question {:q "How do you determine if empty?"
               :c ["empty?", "exist?", "map", "reduce"]
               :a "empty?"
               :l "q3"})

(defn get-question
  [request]
  (ring-resp/response (str question)))

(defn get-correct-choice [q]
  (let [v (:c q)
        a (:a q)]
    (+ 1 (.indexOf v a))))

(defn check-answer
  [request]
  (try
    (let [expr (read-string (slurp (:body request)))
          answer (:answer expr)
          a (if (or (nil? answer) (= answer "")) 0 (Integer. answer)))]
      (if (= a (get-correct-choice question))
        (ring-resp/response "correct")
        (ring-resp/response "incorrect")))
    (catch Throwable t
      (str "ERROR: " t))))

(defroutes routes
  [[["/" {:get home-page}
     ["/check-answer" {:post check-answer}]
     ["/selmer" {:get selmer-page}]
     ["/game" {:get game-page}]
     ["/get-question" {:get get-question}]
     ["/about" {:get about-page}]]]])

(def service {:env :prod
              ::bootstrap/routes routes
              ::bootstrap/resource-path "/public"
              ::bootstrap/type :jetty
              ::bootstrap/port 8080})
```

Some observations:

* `question` is hard-coded in the above example.  However, with very little imagination, students should be able to obtain questions from either the database (using `monger`) or a text file (using `clojure.java.io`).

* We've removed the interceptor, this is primarily due to how code is being passed onto the server.  To put the interceptor back, we'd need to modify `client.cljs` and specify that data being passwd is of type `application/json` *and* actually convert to json format from clojure map.  This process is non-trivial on the client (clojurescript) side.

### Compile and run

To compile and run Open two terminal windows:

* In one terminal type `lein run` inside the `trivia` directory
* In the other terminal, type `lein cljsbuild auto`

Once compilation completes, the trivia game available at `http://localhost:8080/game`.

## Looking ahead

The above example demonstrate that we can create a rather trivial trivia game using everything that we've discussed in class by modifying about 100 lines of code.  The next thing to do is to think about the data that is being passed back and forth and the representation of the a "real" trivia game.  

## References

* [Luminus Web](http://www.luminusweb.net/)
* [Pedestal](https://github.com/pedestal/pedestal)


